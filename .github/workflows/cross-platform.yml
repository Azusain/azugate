name: Azugate Linux CI/CD

# Required permissions for the workflow
permissions:
  contents: write
  packages: read
  actions: read
  security-events: write

on:
  # Manual trigger with release option
  workflow_dispatch:
    inputs:
      create_release:
        description: 'Create a GitHub release (true/false)'
        required: false
        default: 'false'
        type: boolean
      release_version:
        description: 'Release version (e.g., v1.0.0, or leave empty for auto-generation)'
        required: false
        default: ''
        type: string
  # Automatic triggers
  push:
    branches: [ main, develop ]
    tags: [ 'v*' ]
  pull_request:
    branches: [ main ]

jobs:
  build-and-test:
    name: Build and Test
    runs-on: ubuntu-22.04
    
    strategy:
      fail-fast: false
      matrix:
        # Single build for maximum speed - GCC Release only
        include:
          - compiler: gcc
            cc: gcc-11
            cxx: g++-11
            build_type: Release
    
    env:
      CC: ${{ matrix.cc }}
      CXX: ${{ matrix.cxx }}
    
    steps:
    - name: Checkout Repository
      uses: actions/checkout@v4
      with:
        submodules: recursive
    
    # Environment Detection
    - name: Detect Build Environment
      id: env-detect
      run: |
        echo "=== Environment Detection ==="
        
        # Detect runner type
        if [ -n "${{ runner.name }}" ] && [[ "${{ runner.name }}" == "GitHub Actions"* ]]; then
          RUNNER_TYPE="github-hosted"
          echo "🏗️ Detected: GitHub-hosted runner"
        else
          RUNNER_TYPE="self-hosted"
          echo "🏠 Detected: Self-hosted runner"
        fi
        echo "runner_type=$RUNNER_TYPE" >> $GITHUB_OUTPUT
        
        # Check if build tools are already installed
        NEED_SYSTEM_DEPS="true"
        if command -v cmake >/dev/null 2>&1 && command -v ninja >/dev/null 2>&1 && command -v ${{ matrix.cc }} >/dev/null 2>&1; then
          NEED_SYSTEM_DEPS="false"
          echo "✅ Build tools already available: cmake, ninja, ${{ matrix.cc }}"
        else
          echo "📦 Build tools need installation"
        fi
        echo "need_system_deps=$NEED_SYSTEM_DEPS" >> $GITHUB_OUTPUT
        
        # Check if vcpkg is already available
        NEED_VCPKG_SETUP="true"
        if [ -x "vcpkg/vcpkg" ] || command -v vcpkg >/dev/null 2>&1; then
          NEED_VCPKG_SETUP="false"
          echo "✅ vcpkg already available"
        else
          echo "📦 vcpkg needs setup"
        fi
        echo "need_vcpkg_setup=$NEED_VCPKG_SETUP" >> $GITHUB_OUTPUT
        
        # Display environment summary
        echo "=== Environment Summary ==="
        echo "Runner Type: $RUNNER_TYPE"
        echo "Need System Dependencies: $NEED_SYSTEM_DEPS"
        echo "Need vcpkg Setup: $NEED_VCPKG_SETUP"
        echo "OS: $(uname -s)"
        echo "Architecture: $(uname -m)"
        echo "Available CPUs: $(nproc)"
        echo "Memory: $(free -h | grep '^Mem:' | awk '{print $2}' || echo 'N/A')"
    
    # Multi-level aggressive caching strategy
    - name: Cache vcpkg Binary Cache
      uses: actions/cache@v4
      with:
        path: |
          ~/.cache/vcpkg/archives
          ~/.cache/vcpkg/downloads
        key: ${{ runner.os }}-vcpkg-binary-${{ hashFiles('vcpkg.json', 'vcpkg-configuration.json') }}
        restore-keys: |
          ${{ runner.os }}-vcpkg-binary-
    
    - name: Cache vcpkg Installation
      uses: actions/cache@v4
      with:
        path: |
          vcpkg_installed
          vcpkg
        key: ${{ runner.os }}-vcpkg-install-${{ matrix.compiler }}-${{ hashFiles('vcpkg.json', 'vcpkg-configuration.json') }}
        restore-keys: |
          ${{ runner.os }}-vcpkg-install-${{ matrix.compiler }}-
          ${{ runner.os }}-vcpkg-install-
    
    - name: Cache Build Directory
      uses: actions/cache@v4
      with:
        path: |
          build/CMakeFiles
          build/CMakeCache.txt
          build/*.ninja
          build/.ninja*
        key: ${{ runner.os }}-build-${{ matrix.compiler }}-${{ matrix.build_type }}-${{ hashFiles('CMakeLists.txt', 'src/**/*.cpp', 'src/**/*.cc', 'src/**/*.h') }}
        restore-keys: |
          ${{ runner.os }}-build-${{ matrix.compiler }}-${{ matrix.build_type }}-
          ${{ runner.os }}-build-${{ matrix.compiler }}-
    
    # Conditional System Dependencies Installation
    - name: Install System Dependencies (GitHub-hosted runners only)
      if: steps.env-detect.outputs.need_system_deps == 'true'
      uses: awalsh128/cache-apt-pkgs-action@latest
      with:
        packages: build-essential cmake ninja-build git pkg-config curl zip unzip tar ${{ matrix.cc }} ${{ matrix.cxx }}
        version: 1.0
    
    - name: Verify System Dependencies (Self-hosted runners)
      if: steps.env-detect.outputs.need_system_deps == 'false'
      run: |
        echo "=== Using Pre-installed System Dependencies ==="
        echo "CMake: $(cmake --version | head -1)"
        echo "Ninja: $(ninja --version)"
        echo "Compiler: $(${{ matrix.cc }} --version | head -1)"
        echo "Git: $(git --version)"
        echo "✅ All system dependencies are available"
    
    # Conditional vcpkg Setup
    - name: Setup vcpkg (when needed)
      if: steps.env-detect.outputs.need_vcpkg_setup == 'true'
      uses: lukka/run-vcpkg@v11
      with:
        vcpkgGitCommitId: 'cd124b84feb0c02a24a2d90981e8358fdee0e077'
        runVcpkgInstall: true
        # Enable binary caching
        appendedCacheKey: ${{ matrix.compiler }}
        # Use pre-built binaries when possible
        vcpkgJsonGlob: 'vcpkg.json'
    
    - name: Use Existing vcpkg (when available)
      if: steps.env-detect.outputs.need_vcpkg_setup == 'false'
      run: |
        echo "=== Using Pre-existing vcpkg Installation ==="
        if [ -x "vcpkg/vcpkg" ]; then
          VCPKG_CMD="./vcpkg/vcpkg"
          echo "Using local vcpkg: $PWD/vcpkg/vcpkg"
        else
          VCPKG_CMD="vcpkg"
          echo "Using system vcpkg: $(which vcpkg)"
        fi
        
        echo "vcpkg version: $($VCPKG_CMD version)"
        echo "Installing dependencies from vcpkg.json..."
        $VCPKG_CMD install --triplet=x64-linux
        
        # Set VCPKG_ROOT for subsequent steps
        if [ -x "vcpkg/vcpkg" ]; then
          echo "VCPKG_ROOT=$PWD/vcpkg" >> $GITHUB_ENV
        else
          echo "VCPKG_ROOT=$(dirname $(which vcpkg))" >> $GITHUB_ENV
        fi
    
    - name: Configure CMake
      run: |
        cmake -B build \
          -DCMAKE_BUILD_TYPE=${{ matrix.build_type }} \
          -DCMAKE_C_COMPILER=${{ matrix.cc }} \
          -DCMAKE_CXX_COMPILER=${{ matrix.cxx }} \
          -DCMAKE_TOOLCHAIN_FILE=${{ env.VCPKG_ROOT }}/scripts/buildsystems/vcpkg.cmake \
          -G Ninja
    
    - name: Build Project
      run: |
        cmake --build build --config ${{ matrix.build_type }} --parallel $(nproc)
    
    - name: Verify Build Artifacts
      run: |
        echo "=== Build Artifacts ==="
        ls -la build/
        file build/azugate
        ldd build/azugate || echo "Static linking detected"
        
        echo "=== Binary Information ==="
        size build/azugate
        
        echo "=== Testing Executable ==="
        timeout 10s build/azugate --help || echo "Help command test completed"
    
    - name: Run Unit Tests
      if: matrix.build_type == 'Release'
      run: |
        cd build
        ctest --output-on-failure --parallel $(nproc) || echo "No tests configured"
    
    - name: Performance Benchmark
      if: matrix.build_type == 'Release' && matrix.compiler == 'gcc'
      run: |
        echo "=== Performance Metrics ==="
        echo "Binary size: $(stat -c%s build/azugate) bytes"
        echo "Stripped size: $(strip --strip-all build/azugate -o build/azugate_stripped && stat -c%s build/azugate_stripped) bytes"
    
    - name: Upload Build Artifacts
      if: matrix.build_type == 'Release'
      uses: actions/upload-artifact@v4
      with:
        name: azugate-linux-${{ matrix.compiler }}-${{ matrix.build_type }}
        path: |
          build/azugate
          build/*.so*
        retention-days: 7
    
    - name: Upload Test Results
      if: always()
      uses: actions/upload-artifact@v4
      with:
        name: test-results-${{ matrix.compiler }}-${{ matrix.build_type }}
        path: |
          build/Testing/
          build/*.log
        retention-days: 3
        if-no-files-found: ignore

  security-scan:
    name: Security Scan
    runs-on: ubuntu-22.04
    needs: build-and-test
    if: github.event_name == 'push'
    
    steps:
    - name: Checkout Repository
      uses: actions/checkout@v4
    
    - name: Download Build Artifacts
      uses: actions/download-artifact@v4
      with:
        name: azugate-linux-gcc-Release
        path: ./artifacts
    
    - name: Run Security Scan
      run: |
        echo "=== Security Analysis ==="
        
        # Check for hardcoded secrets
        echo "Checking for potential secrets..."
        grep -r -i "password\|secret\|key\|token" src/ || echo "No obvious secrets found"
        
        # Basic binary analysis
        echo "Analyzing binary security features..."
        if command -v checksec &> /dev/null; then
          checksec --file=./artifacts/azugate
        else
          echo "checksec not available, skipping binary security analysis"
        fi
        
        # Check dependencies for known vulnerabilities
        echo "Dependency analysis..."
        ldd ./artifacts/azugate | head -20

  documentation-check:
    name: Documentation Check
    runs-on: ubuntu-22.04
    
    steps:
    - name: Checkout Repository
      uses: actions/checkout@v4
    
    - name: Verify Documentation
      run: |
        echo "=== Documentation Verification ==="
        
        # Check main README.md in root
        if [[ -f "README.md" ]]; then
          line_count=$(wc -l < "README.md" 2>/dev/null || echo "0")
          echo "✅ README.md exists in root ($line_count lines)"
        else
          echo "❌ README.md is missing from root directory"
          exit 1
        fi
        
        # Check documentation files in docs/ folder
        required_docs_in_docs=(
          "BUILD.README.md"
          "LINUX_BUILD.md"
          "GRPC_INTEGRATION_FIXES.md"
        )
        
        doc_check_failed=false
        echo "Checking documentation files in docs/ folder..."
        
        for doc in "${required_docs_in_docs[@]}"; do
          echo "Checking: docs/$doc"
          if [[ -f "docs/$doc" ]]; then
            line_count=$(wc -l < "docs/$doc" 2>/dev/null || echo "0")
            echo "✅ docs/$doc exists ($line_count lines)"
          else
            echo "❌ docs/$doc is missing"
            doc_check_failed=true
          fi
        done
        
        if [[ "$doc_check_failed" == "true" ]]; then
          echo ""
          echo "❌ Some required documentation files are missing from docs/ folder"
          echo "Available files in docs/:"
          ls -la docs/*.md 2>/dev/null || echo "No .md files found in docs/"
          exit 1
        fi
        
        echo ""
        echo "✅ All required documentation files found!"
        echo "  - README.md in root directory"
        echo "  - All other documentation in docs/ folder"
        
        # Check if vcpkg manifest is valid
        echo "Verifying vcpkg configuration..."
        if [[ -f "vcpkg.json" ]]; then
          echo "✅ vcpkg.json exists"
          cat vcpkg.json | jq . > /dev/null && echo "✅ vcpkg.json is valid JSON"
        fi
        
        if [[ -f "vcpkg-configuration.json" ]]; then
          echo "✅ vcpkg-configuration.json exists"
          cat vcpkg-configuration.json | jq . > /dev/null && echo "✅ vcpkg-configuration.json is valid JSON"
        fi

  integration-test:
    name: Integration Tests
    runs-on: ubuntu-22.04
    needs: build-and-test
    
    steps:
    - name: Checkout Repository
      uses: actions/checkout@v4
    
    - name: Download Linux Artifact
      uses: actions/download-artifact@v4
      with:
        name: azugate-linux-gcc-Release
        path: ./linux-build
    
    - name: Setup Test Environment
      run: |
        chmod +x ./linux-build/azugate
        
        # Create test configuration
        mkdir -p test-env
        cd test-env
        
        # Basic configuration file
        cat > config.yaml << EOF
        server:
          port: 8080
          grpc_port: 50051
        logging:
          level: info
        EOF
    
    - name: Run Integration Tests
      timeout-minutes: 2
      run: |
        cd test-env
        
        echo "=== Starting Integration Tests ==="
        
        # Test 1: Configuration validation
        echo "Testing configuration validation..."
        timeout 5s ../linux-build/azugate --config config.yaml --validate || echo "Config validation test completed"
        
        # Test 2: Service startup (background)
        echo "Testing service startup..."
        timeout 10s ../linux-build/azugate --config config.yaml &
        SERVER_PID=$!
        sleep 3
        
        # Test 3: Health check
        if kill -0 $SERVER_PID 2>/dev/null; then
          echo "✅ Server started successfully"
          
          # Test gRPC port (if available)
          if command -v nc >/dev/null; then
            nc -z localhost 50051 && echo "✅ gRPC port accessible" || echo "⚠️ gRPC port not accessible"
          fi
          
          # Test HTTP port (if available)
          if command -v nc >/dev/null; then
            nc -z localhost 8080 && echo "✅ HTTP port accessible" || echo "⚠️ HTTP port not accessible"
          fi
          
          # Cleanup
          kill $SERVER_PID 2>/dev/null || echo "Server already stopped"
        else
          echo "❌ Server failed to start"
        fi

  release:
    name: Create Release
    runs-on: ubuntu-22.04
    needs: [build-and-test, integration-test]
    # Run if: manually requested OR tagged push
    if: (github.event.inputs.create_release == 'true') || startsWith(github.ref, 'refs/tags/v')
    
    steps:
    - name: Checkout Repository
      uses: actions/checkout@v4
      with:
        fetch-depth: 0
    
    - name: Download All Artifacts
      uses: actions/download-artifact@v4
      with:
        path: ./release-artifacts
    
    - name: Generate Release Version
      id: version
      run: |
        if [ -n "${{ github.event.inputs.release_version }}" ]; then
          # Use provided version
          VERSION="${{ github.event.inputs.release_version }}"
          echo "Using provided version: $VERSION"
        elif [[ "${{ github.ref }}" == refs/tags/* ]]; then
          # Use tag name
          VERSION="${{ github.ref_name }}"
          echo "Using tag version: $VERSION"
        else
          # Generate version from date and commit
          VERSION="v$(date +'%Y.%m.%d')-$(git rev-parse --short HEAD)"
          echo "Generated version: $VERSION"
        fi
        echo "RELEASE_VERSION=$VERSION" >> $GITHUB_ENV
        echo "version=$VERSION" >> $GITHUB_OUTPUT
    
    - name: Prepare Release Assets
      run: |
        cd release-artifacts
        
        echo "=== Preparing Release Assets for $RELEASE_VERSION ==="
        
        # Create release packages
        for dir in */; do
          if [[ -d "$dir" ]]; then
            echo "Processing $dir..."
            cd "$dir"
            
            # Find executables and create archives
            if ls azugate* > /dev/null 2>&1; then
              tar -czf "../${dir%/}-${RELEASE_VERSION}.tar.gz" *
              echo "✅ Created: ${dir%/}-${RELEASE_VERSION}.tar.gz"
            fi
            cd ..
          fi
        done
        
        echo "=== Final Release Assets ==="
        ls -la *.tar.gz || echo "❌ No release packages created"
    
    - name: Create GitHub Release
      uses: softprops/action-gh-release@v1
      with:
        tag_name: ${{ env.RELEASE_VERSION }}
        name: "Azugate Release ${{ env.RELEASE_VERSION }}"
        body: |
          ## Azugate Release ${{ env.RELEASE_VERSION }}
          
          ### 🚀 What's New
          - Linux binary (GCC Release build)
          - Optimized with vcpkg dependencies
          - Full gRPC and HTTP support
          
          ### 📦 What's Included
          - `azugate` - Main executable
          - All required dependencies
          
          ### ⚡ Quick Start
          ```bash
          # Download and extract
          wget https://github.com/${{ github.repository }}/releases/download/${{ env.RELEASE_VERSION }}/azugate-linux-gcc-Release-${{ env.RELEASE_VERSION }}.tar.gz
          tar -xzf azugate-linux-gcc-Release-${{ env.RELEASE_VERSION }}.tar.gz
          
          # Run
          ./azugate --help
          ```
          
          ### 🔧 Build Information
          - **Commit**: `${{ github.sha }}`
          - **Build Date**: `$(date -u +'%Y-%m-%d %H:%M:%S UTC')`
          - **Triggered by**: @${{ github.actor }}
          - **Workflow**: ${{ github.workflow }}
        files: |
          release-artifacts/*.tar.gz
        generate_release_notes: true
        draft: false
        prerelease: ${{ contains(env.RELEASE_VERSION, '-') }}
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

  discord-notification:
    name: Discord Notification
    runs-on: ubuntu-22.04
    needs: [build-and-test, security-scan, documentation-check, integration-test, release]
    if: always()
    
    steps:
    - name: Send Discord Notification
      uses: Ilshidur/action-discord@master
      with:
        args: |
          🚀 **Azugate Linux CI/CD Complete!**
          
          **Repository:** ${{ github.repository }}
          **Branch:** ${{ github.ref_name }}
          **Commit:** ${{ github.sha }}
          **Workflow:** ${{ github.workflow }}
          
          **Build & Test:** ${{ needs.build-and-test.result == 'success' && '✅ Success' || '❌ Failed' }}
          **Security Scan:** ${{ needs.security-scan.result == 'success' && '✅ Clean' || needs.security-scan.result == 'skipped' && '⏭️ Skipped' || '❌ Issues' }}
          **Documentation:** ${{ needs.documentation-check.result == 'success' && '✅ Valid' || '❌ Missing' }}
          **Integration Tests:** ${{ needs.integration-test.result == 'success' && '✅ Passed' || '❌ Failed' }}
          **Release:** ${{ needs.release.result == 'success' && '✅ Created' || needs.release.result == 'skipped' && '⏭️ Skipped' || '❌ Failed' }}
          
          **Triggered by:** ${{ github.actor }}
          **View Details:** ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}
      env:
        DISCORD_WEBHOOK: ${{ secrets.DISCORD_WEBHOOK_URL }}
